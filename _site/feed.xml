<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>向涛</title>
    <description>Welcome to my personal website~</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 20 Mar 2022 09:50:03 +0800</pubDate>
    <lastBuildDate>Sun, 20 Mar 2022 09:50:03 +0800</lastBuildDate>
    <generator>Jekyll v4.2.1</generator>
    
      <item>
        <title>c++笔记</title>
        <description>&lt;h2 id=&quot;1基本的细节知识&quot;&gt;1.基本的细节知识&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.14&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//这里3.14f加f的原因是由于c++中的小数默认是double,由于这里使用的是float接受，因此不加f内部会进行强制转换，加了f不用转换&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//c++中sizeof函数里面可以放关键字int，也可以用变量名a，功能是计算其字节的大小，一般在c++中对整型而言，占用字节如下&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//short: 2byte,int: 4byte,long: 8byte(linux 64位) 4byte(windows和linux(32位)) long long:8byte&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//科学计数法&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3e2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//表示3*10^2&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3e-2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//表示3*10^-2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//字符型与类型转换&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'a'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//true&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//error 不可以为双引号&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;abc&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// error 只允许一个字符，不能多个&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//值得注意的是字符在计算机中存储是用ASCII编码进行的，例如a=97,b=98;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//result: a&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//result: 97，注意这里使用了类型转换，转换的方式为:(类型)变量名。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//转义字符 \t:表示八个空格，一般用于输出对齐的效果&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;aaa&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//这里aaa后面加五个空格就等于八个位置，因此与hello之间有五个空格，如何是aaaa，那么就剩下四个空格。&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;aaaaaaaaab&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//这里的hello之前有八个a和一个b，占了九个位置，那么此时\t就表示16个空格。两个\t也表示16个空格，以次类推。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//c++中的数组，有两个特点&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//1.数组中每个元素的数据类型一致&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//2.存在在一个连续的内存中，这也为后面的指针索引做了铺垫。&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//3.关于数组的初始化，例如&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//得出的结果将是不确定的数字，但不会报错，这将是很危险的操作&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//得到的结果全是0，一般用于初始化为0时候使用&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//结果为1 0 0,此时c++会把后面不够赋初值的数组全部默认为0&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//总之就是记得初始化，否则将会得到难以预料的结果。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//c++中一维数组名的用处&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//1.可以统计整个数组在内存中的长度&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//2.可以获取数组在内存中的首地址&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//此时arr,&amp;amp;arr与&amp;amp;arr[0]三者的结果是一样的&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//同时应当注意数组名是一个常量不能够重新赋值&lt;/span&gt;
   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//c++中二维数组的属性和上面的一维数组一致，不过维度增加了，有部分的差异，详细可以自行体会。&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//二维数组中数据在内存中的存贮顺序是按照行的顺序来的。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//函数的值传递，形参发生交换并不影响实参&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//函数的声明可以多次，但是定义只能一次&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//指针存储的是一个地址，32位系统占用4个字节，64位系统占用8个字节&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//表示空指针，当一开始不确定指针指向的位置时候使用，本质上是将指针指向了内存为内存编号0的空间，计算机中0-255编号的内存为系统占用，不允许访问，因此访问空指针程序会报错。&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//指针与普通的变量有着类似的表现，只不过指针存储的是一个地址，因此指针可以进行加减，但是请注意一般是与数组结合用于p++,p--情况。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;代码的存储分为了代码区，全局区，栈区，堆区，其中在可执行文件中(linux:out windows:exe)，代码只分配在全局区和代码区，执行可执行文件时候，栈区的代码由操作系统控制释放，堆区由程序员管理，注意栈区中的变量基本是临时变量，因此在函数返回地址时候要注意不要返回栈区的地址，否则会出现意料之外的bug。详情看bilibili黑马程序员处讲解。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;应当记住的是，c++中引用，指针，const等在函数返回类型，函数参数传递类型等地方需要进行考虑，比如该函数的参数是否要使用const，应该是能使用 const就应当使用，还有就是返回类型是否需要引用等，返回地址，引用不能是临时变量(局部变量)等。&lt;strong&gt;返回引用的函数还可以作为左值，例如test()=20;其中test函数是返回引用的函数&lt;/strong&gt;。这里可以理解为test()函数就相当于返回数据的那个变量，不同的名字而已，同时返回引用也可用不是引用的形式接收，例如可以int&amp;amp; a = test()，也可以int a = test()。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果函数声明有默认参数，函数实现就不能有默认参数，否则产生二义性，编译器报错。声明和实现只能有一个有默认参数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;函数占位参数形如：function(int a,int)，后面的int就表示占位参数，调用函数时候需要给定才可以。除此之外占位参数还可以有默认参数，形如function(int a,int=10)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;函数重载的注意事项：引用和常量引用可以作为重载条件，形如func(int &amp;amp;a)与func(const int &amp;amp;a)可以重载，此时变量调用无const的函数，const修饰的变量和常数，如10，20，即func(10)会走有const的函数。此外默认参数有时候也会出现二义性，形如:func(int a,int b=10)和func(int a)，调用时候使用func(10)，这时候就出现了两个函数均可调用的情况，编译器报错，所以这时候应该尽量避免使用默认参数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;构造函数的调用方式：&lt;/p&gt;

    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//括号法&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;；&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//默认构造调用&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;；&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//有参构造调用&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//拷贝函数调用&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//显示法&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;；&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//默认构造调用&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;；&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//有参构造调用&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//拷贝函数调用&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//常用的是括号法&lt;/span&gt;
        
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;请注意在成员属性中含有指针情况下，应该在堆区创建数据，同时需要在析构函数中自行释放，但是&lt;strong&gt;如果有拷贝问题则需要重新写拷贝构造函数，否则会造成浅拷贝&lt;/strong&gt;，详细分析看bilibili视频。&lt;/li&gt;
  &lt;li&gt;在初始化类的数据时候，一般会使用构造函数，但是能&lt;strong&gt;够使用初始化列表情况下应该使用初始化列表&lt;/strong&gt;，见视频侯捷讲解，初始化列表使用见黑马视频。&lt;/li&gt;
  &lt;li&gt;在一个类中构造函数和析构函数的先后顺序是先进后出（即栈的功能），即先用类初始化的对象先构造，后析构。但是当一个类中含有另一个类的对象时候的顺序如何呢，形如&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;B&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//结论：当其他类对象作为本类的成员，则先构造其他类的对象，再构造本类。析构顺序正好相反，这也恰好符合了栈的先进后出规则。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;静态成员函数：所有对象共享同一个函数，且只能访问静态成员变量，访问静态成员函数除了使用对象通过点来访问外，还可以通过类名与双冒号访问，和命名空间中的有点像，同时也和普通成员函数一样拥有访问权限设置，&lt;strong&gt;初始化需要在类外声明&lt;/strong&gt;。详见黑马视频。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;c++中的this指针：&lt;/strong&gt;c++类中成员函数和成员变量是分开存储的，类的占用字节大小只和非静态的成员变量有关。一个空的类中声明的对象称为空对象，它占用一个字节，之所以占用一个字节是因为当有多个空对象时候好区分其在内存中的位置分配。不是空的类，则按照非静态成员变量的字节总数计算对象的字节数。为了区分那个对象调用自己（成员函数），this指针起到了作用，它指向被调用的成员函数所属的对象，一般this指针的用途包含解决名称冲突和返回调用对象本身，每一个非静态成员函数都隐藏了一个this指针，可以直接使用，静态成员函数没有this指针，this指针的本质是指针常量，即指针指向的内存无法修改。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;空指针访问成员函数：&lt;/strong&gt;详见黑马视频，大致意思如下：&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;showclassName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;showPersonAge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//showclassNmae和showPersonAge是Person的成员函数&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//结论：空指针可以访问一般的成员函数，前提是不要设计到this指针，即一般不能够访问成员属性，可以访问一般的打印输出。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;const修饰的成员函数叫做常函数，同理使用const修饰的对象叫做常对象，常对象只能调用常函数，请注意const修饰类中的成员函数位置和修饰普通函数的位置，一般而言const修饰成员函数控制的数据是调用该函数的对象数据，即控制this指针，成员属性想要修改可以加关键词mutable，控制this指针的const放在成员函数的括号后面，和普通函数一样，也可以在成员函数的返回值类型前加const，此时该const修饰的是成员函数的返回值不能够修改，一个修饰this指针，一个修饰成员函数的返回值。参数一样可以添加const属性。&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 02 Mar 2022 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/03/cpp%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/03/cpp%E7%AC%94%E8%AE%B0/</guid>
        
        <category>c++</category>
        
        
      </item>
    
      <item>
        <title>python虚拟环境</title>
        <description>&lt;h2 id=&quot;python虚拟环境注意事项&quot;&gt;python虚拟环境注意事项&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;新建一个文件夹用于存储虚拟环境的内容，例如 mkdir venv&lt;/li&gt;
  &lt;li&gt;创建一个虚拟环境包，例如 python3 -m venv tutorial-env(包名)&lt;/li&gt;
  &lt;li&gt;激活环境&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;Windows：tutorial-env\Scripts\activate.bat&lt;/li&gt;
  &lt;li&gt;Linux or Mac：source tutorial-env/bin/activate&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;测试是否成功：例如使用which pip，得到的路径与虚拟环境匹配则成功，如果还是全局路径，则需要删除整个文件夹，新建一个文件，在从2部开始，然后激活环境后使用chmod -R 755 包名，再进行测试应该就可以了。&lt;/li&gt;
  &lt;li&gt;在虚拟环境下运行python代码将采用虚拟环境提供的包，在同时使用pip安装和卸载以及升级等操作也是对虚拟环境下的包进行操作，不会影响全局路径下的包，好处在于和全局路径可以享用不同版本的包，同时对于某些不常用的包在虚拟路径下是不会对全局路劲下的包产生额外污染。&lt;/li&gt;
  &lt;li&gt;如何退出虚拟环境:运行deactivate(注意Windows需要到指定路径下运行)&lt;/li&gt;
  &lt;li&gt;Pycharm中如何使用虚拟环境：自行百度或者b站有视频，很简单。&lt;/li&gt;
  &lt;li&gt;上述的方式在使用过程中，当需要不同虚拟环境进行切换会带来麻烦，因此可以使用pip安装一个包，包名是virtualenvwrapper，安装方式：&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;Windows：pip install virtualenvwrapper-win&lt;/li&gt;
  &lt;li&gt;ubuntu: pip install virtualenvwrapper&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;还需要配置或者进行激活，然后使用相关的命令会很方便。详细信息可以百度或者谷歌。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如何将虚拟环境打包给其他人使用：pip freeze&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;将生成一个类似的已安装包列表，但输出使用预期的格式。一个常见的约定是将此列表放在一个文件中：&lt;/code&gt;pip install requirements.txt，具体的做法类似如下操作：&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tutorial&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pip&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;freeze&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requirements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;txt&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tutorial&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requirements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;txt&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;novas&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;3.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.3&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;numpy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;requests&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;chmod -R 755&lt;/p&gt;

&lt;p&gt;将txt文件和包一并发送给用户，然后用户操作大致是：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tutorial&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;python&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pip&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requirements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;txt&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Collecting&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;novas&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;3.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requirements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;txt&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Collecting&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numpy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requirements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;txt&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Collecting&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requests&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requirements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;txt&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Installing&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;collected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;packages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;novas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requests&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Running&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;novas&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Successfully&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;installed&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;novas&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;3.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numpy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requests&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;官方参考网址：https://docs.python.org/3/tutorial/venv.html&lt;/p&gt;
</description>
        <pubDate>Thu, 04 Nov 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/11/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/11/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</guid>
        
        <category>pip</category>
        
        
      </item>
    
      <item>
        <title>磁流效应CMP润滑方程差分格式推导</title>
        <description>&lt;p&gt;需要求解方程模型如下所示：&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://cdn.jsdelivr.net/gh/xiang-tao/image-hosting@master/CMP-picture/18.3zroeovshqi0.png&quot; width=&quot;60%&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;磁流效应的润滑方程&lt;/div&gt;
&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;先对方程的左边进行中心差分离散&lt;/strong&gt;，在点(\(r_i,\theta_j\))处展开，模板点包括了(\(r_i,\theta_{j-1}\))，(\(r_i,\theta_j\))，(\(r_i,\theta_{j+1}\))，(\(r_{i-1},\theta_j\))，(\(r_{i+1},\theta_j\))&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://cdn.jsdelivr.net/gh/xiang-tao/image-hosting@master/CMP-picture/IMG_20211008_131547.46z88xpnfro0.jpg&quot; width=&quot;60%&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;差分格式推导&lt;/div&gt;
&lt;/center&gt;
&lt;p&gt;其中hr表示表示r方向的分割步长，h\(\theta\) 表示$\theta$ 方向的步长，h表示在不同点处的膜厚，因此它与(r,\(\theta\))相关，其表达式如下：&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://cdn.jsdelivr.net/gh/xiang-tao/image-hosting@master/CMP-picture/22.37rp9s43vim0.png&quot; width=&quot;60%&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;膜厚h表达式&lt;/div&gt;
&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;对于右边项的处理：&lt;/strong&gt;&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://cdn.jsdelivr.net/gh/xiang-tao/image-hosting@master/CMP-picture/IMG_20211008_134038.1fa7s5dffb6o.jpg&quot; width=&quot;60%&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;右端项分析&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;上面的一些函数表达式如下：&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://cdn.jsdelivr.net/gh/xiang-tao/image-hosting@master/CMP-picture/19.6bfvzwqk5xg0.png&quot; width=&quot;60%&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;(1)&lt;/div&gt;
&lt;/center&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://cdn.jsdelivr.net/gh/xiang-tao/image-hosting@master/CMP-picture/20.3xkwn7maha40.png&quot; width=&quot;60%&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;(2)&lt;/div&gt;
&lt;/center&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://cdn.jsdelivr.net/gh/xiang-tao/image-hosting@master/picture/12.5nc0z2tduzo0.png&quot; width=&quot;60%&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;(3)&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;根据(3)式可以代入函数f1与f2求导后便可以得到关于(\(r,\theta\))的表达式，因此在点(\(r_i,\theta_j\))处的函数值可以表示为\(f1_{ij}\)与\(f2_{ij}\)，同理根据(2)是可以得到函数f4与f5的表达式，最后关于函数f5中磁场强度H是给定的已知值，这样右端项\(f_{ij}\)在离散点上的值就都能够计算出来了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://cdn.jsdelivr.net/gh/xiang-tao/image-hosting@master/CMP-picture/IMG_20211008_141323.7iqdkoxjosc0.jpg&quot; width=&quot;60%&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;差分格式结果&lt;/div&gt;
&lt;/center&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://cdn.jsdelivr.net/gh/xiang-tao/image-hosting@master/CMP-picture/21.3k2apt1h7g00.png&quot; width=&quot;60%&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;剖分示意图&lt;/div&gt;
&lt;/center&gt;
</description>
        <pubDate>Fri, 08 Oct 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/10/CMP%E6%A8%A1%E5%9E%8B%E6%96%B9%E7%A8%8B%E7%9A%84%E5%B7%AE%E5%88%86%E6%A0%BC%E5%BC%8F%E6%8E%A8%E5%AF%BC/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/10/CMP%E6%A8%A1%E5%9E%8B%E6%96%B9%E7%A8%8B%E7%9A%84%E5%B7%AE%E5%88%86%E6%A0%BC%E5%BC%8F%E6%8E%A8%E5%AF%BC/</guid>
        
        <category>PaperNotes</category>
        
        
      </item>
    
      <item>
        <title>关于pip与Python</title>
        <description>&lt;p&gt;出现1980错误：在当前文件下打开终端运行find . -type f -exec touch {} +&lt;/p&gt;

&lt;p&gt;要获取pip安装包的可用版本、当前安装版本和最新版本号可以使用命令：&lt;strong&gt;pip index versions 包名&lt;/strong&gt;，但是请注意这是pip版本在21.2以上的才有这个命令，并且命令可能是临时的，后面随时可能会发生更改和删除。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;也可以使用pip先安装yolk3k，然后使用yolk3k来查看某包的最新版本，即&lt;strong&gt;sudo pip3 install yolk3k&lt;/strong&gt;，接着使用命令&lt;strong&gt;yolk -V 包名&lt;/strong&gt;查看最新版本，除此之外**pip3 list&lt;/td&gt;
      &lt;td&gt;grep frogpy&lt;strong&gt;，&lt;/strong&gt;pip3 freeze&lt;/td&gt;
      &lt;td&gt;grep frogpy&lt;strong&gt;，以及&lt;/strong&gt;pip3 show 包名**，可以查看当前版本信息，具体可以自行百度(注意list和freeze区别在于freeze只会显示自己安装的包，不含系统自带的，而list包含了系统自带的包，在虚拟环境中可以看出他们的作用)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;相关细节：注意文件结构，setup.py的写法，需要安装的配置环境，文件init.py的写法，那些需要加from .import 文件名等内容，相关的命令如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;sudo python3 setup.py install 安装解压后的文件，也可以直接使用pip install 压缩包名，反正记住安装方式是多样的。&lt;/li&gt;
  &lt;li&gt;也可以直接在frogpy目录下运行sudo python3 setup.py install，值得注意的是上面的这些安装方法包括下面使用pip安装pypi网站里的包，安装后的内容是python导入包的一些默认路径，但是可能一些设置的原因导致默认的路径有几个，例如我的就有什么lib/local/…下的，也有lib/python3/…下的，更甚至在我的home文件下的一个隐藏文件中.local中也有，但是可以通过设置来改变他们默认的安装路径，也可以在安装时候加入安装的路径，具体操作可以百度。使用pip install . 不出意外也可以安装成功。&lt;/li&gt;
  &lt;li&gt;其次还需要说明的是，也可以使用sudo python3 setup.py develop进行安装，与sudo python3 setup.py install 的区别在于install安装在与pip安装的目录可能一致，并且在python导入包的一些默认路径中，例如lib/local等，但是使用develop就相当于把当前的frogpy当成了导入包的默认路径了，因此路径就在frogpy，好处在于你以后在里面的更新可以直接使用，具体说法是：1.在安装某个库或包时，发现可以python setup.py install 和python setup.py develop两种方式来安装，这两种方法有什么不同？一直困扰着我，下面我们就来讨论下这个简单的问题 2.python setup.py install：主要是安装典型第三方包，这种包比较稳定，不再需要你去编辑、修改或是调试。3.python setup.py develop:当你安装一个包后，这个包需要你不断修改，这样你就不得不重新安装，这时就采用这种安装方法。&lt;/li&gt;
  &lt;li&gt;最后是无论是使用install develop或者pip安装后都可以通过sudo pip3 uninstall frogpy进行卸载，注意有时候使用pip直接安装后，再使用pip卸载时候说没有这个包，但是包确实又存在，那说明这个默认路径下pip无法读取，为什么会安装在这个路径，可能是一些设置造成的，但是跟上面一样可以修改默认路径，如果pip uninstall无法卸载就只有通过__file__来获取路径后到该路径下删除相应的文件夹即可，还可能会有很多其他情况，我目前还没有遇到不过都可以通过谷歌或者百度上进行搜索解答疑问。&lt;/li&gt;
  &lt;li&gt;python3 setup.py sdist 生成上传的.tar.gz文件，当然后缀名可以自行设置，操作自行百度或者b站视频&lt;/li&gt;
  &lt;li&gt;python3 setup.pt bdist_wheel 生成山传的.whl格式文件，还有其他的一些文件格式以及特定系统的安装文件，具体可以百度和看b站相关视频&lt;/li&gt;
  &lt;li&gt;twine upload dist/文件名 将文件格式上传到pypi网站上，更新版本时候注意版本号的更改，在setup.py中，否则会报错&lt;/li&gt;
  &lt;li&gt;使用pip3 install 包名(frogpy)进行安装(在mac或者Windows下也应该是这样).&lt;/li&gt;
  &lt;li&gt;最后一点是上传时候需要输入用户名和密码，如果申请了令牌，这用户名是__token__，密码是令牌，在ubuntu下可以在home目录的用户目录下建立一个隐藏文件，取名为.pypirc，输入如下内容：&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[distutils]
index-servers = pypi
 
[pypi]
//注意username中申请了令牌写如下的token，否则写自己pypi网站申请的用户名
username:__token__
password:申请了令牌需要输入令牌，否则请输入密码
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Wed, 06 Oct 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/10/use_pip/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/10/use_pip/</guid>
        
        <category>pip</category>
        
        
      </item>
    
      <item>
        <title>animation-pictue</title>
        <description>&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://cdn.jsdelivr.net/gh/xiang-tao/image-hosting@master/animation/many_lines_animation.25vz49udwnuo.gif&quot; width=&quot;60%&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;多曲线动态图1&lt;/div&gt;
&lt;/center&gt;
</description>
        <pubDate>Wed, 22 Sep 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/09/animation/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/09/animation/</guid>
        
        <category>animaiton</category>
        
        
      </item>
    
      <item>
        <title>铁磁流体动力学第二章</title>
        <description>&lt;h2 id=&quot;21-铁磁畴结构理论&quot;&gt;2.1 铁磁畴结构理论&lt;/h2&gt;

&lt;h3 id=&quot;211-铁磁矿&quot;&gt;2.1.1 铁磁矿&lt;/h3&gt;

&lt;p&gt;铁磁流体由铁磁颗粒、表面活性剂和载体溶液三要素组成，铁磁颗粒通常来源于含铁的混合物，铁磁颗粒分散于载体溶液中，表面活性剂吸附于铁磁颗粒表面制成&lt;strong&gt;胶态磁性材料&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;铁磁流体的矫顽力分为磁感矫顽力和内禀矫顽力。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;磁感矫顽力&lt;/strong&gt;：磁体在反向充磁时，使磁感应强度降为零所需要反向磁场的值称为磁感矫顽力。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内禀矫顽力&lt;/strong&gt;：使磁化强度将为零所需要施加的反向磁场强度称为铁磁流体的内禀矫顽力。&lt;/p&gt;

&lt;p&gt;物质磁性分类：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;抗磁性：指一种弱磁性。&lt;/li&gt;
  &lt;li&gt;顺磁性：是指材料对磁场很弱的磁性。&lt;/li&gt;
  &lt;li&gt;超顺磁性：是指铁磁物质的颗粒小于临界尺寸时所具有的单畴结构。&lt;/li&gt;
  &lt;li&gt;亚铁磁性：是在无外加磁场的情况下，磁畴内相邻原子间电子交换作用或其他相互作用，使他们的磁矩在克服热运动的影响后，处于部分抵消的有序排列状态，以至于还有一个和磁矩的现象。&lt;/li&gt;
  &lt;li&gt;反铁磁性。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;212-铁磁畴结构理论&quot;&gt;2.1.2 铁磁畴结构理论&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;磁畴&lt;/strong&gt;：在无外磁场的情况下，他们的自旋磁矩能在一个个微小区域内“自发地”整齐排列起来而形成自发磁化小区域称为磁畴&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;磁畴壁&lt;/strong&gt;：各个磁畴之间的交界面称为磁畴壁。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;饱和磁化&lt;/strong&gt;：当外磁场强度增加到一定程度时，所有磁畴中的磁矩的磁化方向全部与外磁场的方向完全一致，此时磁体就达到了磁饱和状态，即磁饱和化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;残余磁感应强度&lt;/strong&gt;：当达到磁饱和化后，即使磁场减小到零，磁矩也不会回到零，残留下一些磁化效应，这种残留磁化值称为残余磁感应强度。&lt;/p&gt;

&lt;h2 id=&quot;22-铁磁流体基本载液和表面活性剂特性&quot;&gt;2.2 铁磁流体基本载液和表面活性剂特性&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;基载液基本特性&lt;/strong&gt;：低蒸发率、低粘度和高化学稳定性，以及耐高温和抗辐射特性等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;表面活性剂&lt;/strong&gt;：表面活性剂主要用来防止磁性颗粒的氧化，削弱静磁吸引力，克服范德瓦尔斯力的颗粒凝聚。&lt;/p&gt;

&lt;h2 id=&quot;23-铁磁流体颗粒的基本结构及其稳定性&quot;&gt;2.3 铁磁流体颗粒的基本结构及其稳定性&lt;/h2&gt;

&lt;h3 id=&quot;231-克服重力场的稳定性问题&quot;&gt;2.3.1 克服重力场的稳定性问题&lt;/h3&gt;

&lt;p&gt;重力和磁力相对影响描述如下比值：&lt;/p&gt;

\[\frac{重力势能}{磁能} = \frac{\Delta\rho g L}{u_0MH}\]

&lt;p&gt;当对上述参数取典型附加值时候，比值大约为0.047。因此重力对这些磁性流体的下沉作用比磁力要小很多。&lt;/p&gt;

&lt;h3 id=&quot;232-避免凝聚的稳定性问题&quot;&gt;2.3.2 避免凝聚的稳定性问题&lt;/h3&gt;

&lt;p&gt;典型胶状的铁磁流体包含颗粒量级为每立方米\(10^{23}\)，而且颗粒之间频繁碰撞。因此如果颗粒粘连在一起，会迅速凝聚起来，为了保证一对直径为d的铁磁颗粒保持分离，需要足够大的能量。通过实验和理论计算表明，保持铁磁颗粒的最大直径，能明显保证悬浮液的降沉稳定性。&lt;/p&gt;

&lt;h2 id=&quot;24-铁磁流体的基本物理参数&quot;&gt;2.4 铁磁流体的基本物理参数&lt;/h2&gt;

&lt;h3 id=&quot;241-铁磁流体的粘度&quot;&gt;2.4.1 铁磁流体的粘度&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Einstein公式&lt;/strong&gt;：&lt;/p&gt;

\[\eta_0=\eta_c\left\{  1+\frac{5}{2}\widetilde{\phi}  \right\}\]

&lt;p&gt;\(\eta_c\)表示在没有磁场条件下的悬浮液的动力学粘度，
\(\widetilde{\phi}\)表示铁磁颗粒体积浓度为0.06.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vand公式&lt;/strong&gt;：&lt;/p&gt;

\[\eta_0=\eta_c exp\frac{2.5\widetilde{\phi}+2.7\widetilde{\phi}^2}{1-0.609\widetilde{\phi}}\]

&lt;p&gt;&lt;strong&gt;改进的Vand公式&lt;/strong&gt;：
\(\eta_0=\frac{\eta_c}{1-2.5\widetilde{\phi}+\alpha\widetilde{\phi}^2}\)&lt;/p&gt;

&lt;p&gt;通过计算可得\(\alpha = 1.55\)，于是得到刚性堆砌条件下&lt;strong&gt;铁磁流体的粘度公式&lt;/strong&gt;：&lt;/p&gt;

\[\eta_0=\frac{\eta_c}{1-2.5\widetilde{\phi}+1.55\widetilde{\phi}^2}\]

&lt;h3 id=&quot;242-铁磁流体的磁化强度&quot;&gt;2.4.2 铁磁流体的磁化强度&lt;/h3&gt;

&lt;p&gt;磁化强度：磁化强度是描述磁介质磁化状态的物理矢量，通常用M表示，其定义为介质微小体元\(\Delta V\)内的全部磁矩矢量和与\(\Delta V\)之比，即&lt;/p&gt;

\[M = \frac{\sum m_i}{\Delta V}\]

&lt;p&gt;设外磁场的强度为H，磁感应强度为B，\(u_0 = 4\pi \times 10^{-7}\)为真空磁导率，磁化率为\(\chi\)，顺磁质\(\chi\)为正，抗磁质\(\chi\)为负，且他们满足如下关系：&lt;/p&gt;

\[B=\chi H = \frac{\chi}{(1+\chi)u_0}B\]

&lt;h2 id=&quot;25-热磁不稳定性&quot;&gt;2.5 热磁不稳定性&lt;/h2&gt;

&lt;p&gt;不稳定问题产生的有趣现象还包括不稳定性使磁流体中一个薄层出现迷宫一样的图案，加强磁场后还可能出现更多图案，考虑温度对磁场的额依赖，一些热对流不稳定性被提出来，这些现象在数学上被看成是一些临界现象，或是某种分界点。进而形成一些流场的新的超临界平衡状态。在磁场的粘性粘性条件下，&lt;strong&gt;还会发生热磁对流现象，称为热磁不稳定性&lt;/strong&gt;。经过实验观察发现，铁磁流体具有一些独特的热力学性质，在&lt;strong&gt;交变磁场下磁流体可将磁能转化为热能&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;26-铁磁颗粒的体积分数&quot;&gt;2.6 铁磁颗粒的体积分数&lt;/h2&gt;

&lt;p&gt;铁磁流体的体积分数和密度关系式为&lt;/p&gt;

\[\rho = \rho_s\phi_s+\rho_a(\phi_c-\phi_a)+\rho_c(1-\phi_c)\]

&lt;p&gt;上式中\(\phi_s~\phi_a~\phi_c\)分别表示铁磁颗粒、表面活性剂和载体溶液的体积分数，当\(\phi_a = \phi_c\)时，可以简写为&lt;/p&gt;

\[\rho = \rho_s\phi_s+\rho_c(1-\phi_c)\]

&lt;p&gt;由此仅通过测量磁性液体的密度就可以根据组分来确定铁磁颗粒的体积分数&lt;/p&gt;

\[\phi_s = (\rho-\rho_c)/(\rho_s-\rho_c)\]
</description>
        <pubDate>Sat, 18 Sep 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/09/%E9%93%81%E7%A3%81%E6%B5%81%E4%BD%93%E5%8A%A8%E5%8A%9B%E5%AD%A6%E7%AC%AC%E4%BA%8C%E7%AB%A0/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/09/%E9%93%81%E7%A3%81%E6%B5%81%E4%BD%93%E5%8A%A8%E5%8A%9B%E5%AD%A6%E7%AC%AC%E4%BA%8C%E7%AB%A0/</guid>
        
        <category>Ferrohydrodynamics</category>
        
        
      </item>
    
      <item>
        <title>铁磁流体动力学第一章</title>
        <description>&lt;h2 id=&quot;11-麦克斯韦电磁学理论&quot;&gt;1.1 麦克斯韦电磁学理论&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;麦克斯韦&lt;/strong&gt;简短的四元方程组(看起来简短，但却非常复杂)，就可以准确的描绘出电磁场的特性及相互作用关系，这样&lt;strong&gt;麦克斯韦&lt;/strong&gt;将混乱纷纭的现象统一了起来。&lt;strong&gt;麦克斯韦&lt;/strong&gt;方程组优点在于它的通用性，在任何情况下都能够使用，所有的电磁理论都可以由麦克斯韦方程推导出来，许多以前未能解决的问题也能从中寻求答案。&lt;strong&gt;麦克斯韦&lt;/strong&gt;还预言了光也是一种电磁波，同时麦克斯韦方程还表明了可见光并不是唯一的电磁辐射，后来&lt;strong&gt;赫兹&lt;/strong&gt;从理论上验证了麦克斯韦预言的不可见光波，几年后&lt;strong&gt;马可尼&lt;/strong&gt;发现这些不可见的光波可用于无线电通信，无线电随之问世。直到今天我们也在用不可见光进行通信。X射线、\(\gamma\)射线，红外线，紫外线这些都是电磁波辐射的其他一些例子，都可以用麦克斯韦方程进行研究。&lt;/p&gt;

&lt;h2 id=&quot;12-铁磁流体动力学基本内容&quot;&gt;1.2 铁磁流体动力学基本内容&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;主要的三类特殊流体&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;电动流体动力学(&lt;strong&gt;FHD&lt;/strong&gt;)：主要考虑电场对流体的作用，一般不考虑磁场作用。&lt;/li&gt;
  &lt;li&gt;磁流体动力学(&lt;strong&gt;MHD&lt;/strong&gt;)：同时考虑电场和磁场的综合作用。&lt;/li&gt;
  &lt;li&gt;铁磁流体动力学(&lt;strong&gt;FHD&lt;/strong&gt;)：主要考虑磁场对流体的动力学作用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当电场和磁场同时存在，运动的电荷会受到电场力和洛伦磁力，则运动点电荷受力为电场力和洛伦磁力之和&lt;/p&gt;

\[\pmb{F} = q(\pmb{E}+\pmb{v}\times\pmb{B})\]

&lt;p&gt;其中\(\pmb{F}\)是伦伦磁力，q是带电粒子的电荷量，\(\pmb{E}\)是电场强度，\(\pmb{v}\)是带电粒子的速度，\(\pmb{B}\)是磁感应强度。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;洛伦磁力的方向&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.用左手定则来判断：让磁感线穿过手心，四指指向正电荷运动的方向(或负电荷运动方向的反方向)，大拇指指向就是洛伦兹力的方向。&lt;/p&gt;

&lt;p&gt;2.无论v与B是否垂直，洛伦兹力总是同时垂直于电荷运动方向与磁场方向。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;洛伦磁力的特点&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;洛伦兹力的方向总与粒子运动的方向垂直，洛伦兹力只改变速度的方向，不改变速度的大小，故洛伦兹力永远不会对v有积分，即洛伦兹力永不做功。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;洛伦磁力和安培力关系&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;安培力是洛伦兹力的宏观表现，洛伦兹力是安培力的微观实质。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;铁磁流体的组成&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;铁磁颗粒、表面活性剂、载体溶液三要素构成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;铁磁流体的分类&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;根据所含铁磁颗粒的不同，可分为铁氧体系、金属系和氮化铁系。&lt;/li&gt;
  &lt;li&gt;根据基液的不同可分为水基、油基、醚基和酯基。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;铁磁流体的特点&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;铁磁流体和外界磁场的响应性。&lt;/li&gt;
  &lt;li&gt;铁磁流体的磁化强度感应性。&lt;/li&gt;
  &lt;li&gt;铁磁流体的磁粘滞现象。&lt;/li&gt;
  &lt;li&gt;超声波和光在铁磁流体中表现出较大的能量耗散和各向异性。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;13-铁磁流体动力学的发展现状&quot;&gt;1.3 铁磁流体动力学的发展现状&lt;/h2&gt;
&lt;p&gt;1963年美国的Papell获得了第一个铁磁流体制备专利，并于1965年在美国国家航天局(NASA)航天产品的密封中被成功应用，自此引发了对这种新型材料的研究开发和应用，并不断取得进展。后来铁磁流体力学的理论研究迅速发展，特别是美国和前苏联在该领域取得了许多重要成就。&lt;/p&gt;

&lt;h2 id=&quot;14-铁磁流体动力学的应用&quot;&gt;1.4 铁磁流体动力学的应用&lt;/h2&gt;

&lt;p&gt;铁磁流体的应用现已扩展到机械、电子、能源、化工、冶金、船舶、航天、医疗等诸多领域，在密封、冷却、润滑、发动机、阻尼震动、快速印刷等方面有着新的应用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;铁磁流体颗粒表面的活性剂是人工弄上去的吗?&lt;/li&gt;
  &lt;li&gt;文中的洛伦磁力公式中F应该是电荷所受的电场力和洛伦磁力之和，为什么两个力之和还叫洛伦磁力呢?&lt;/li&gt;
  &lt;li&gt;铁磁流体的特点不太理解。&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 18 Sep 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/09/%E9%93%81%E7%A3%81%E6%B5%81%E4%BD%93%E5%8A%A8%E5%8A%9B%E5%AD%A6%E7%AC%AC%E4%B8%80%E7%AB%A0/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/09/%E9%93%81%E7%A3%81%E6%B5%81%E4%BD%93%E5%8A%A8%E5%8A%9B%E5%AD%A6%E7%AC%AC%E4%B8%80%E7%AB%A0/</guid>
        
        <category>Ferrohydrodynamics</category>
        
        
      </item>
    
      <item>
        <title>考虑对流效应和磁场的CMP模型及数值模拟论文笔记</title>
        <description>&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://cdn.jsdelivr.net/gh/xiang-tao/image-hosting@master/picture/CMP.6wtduy66xrk0.png&quot; width=&quot;60%&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;CMP工作示意图&lt;/div&gt;
&lt;/center&gt;

&lt;h2 id=&quot;具有对流效应的cmp润滑方程的推导&quot;&gt;具有对流效应的CMP润滑方程的推导&lt;/h2&gt;

&lt;p&gt;连续方程为：&lt;/p&gt;

\[\begin{equation}
\nabla\cdot\pmb{u} = 0
\end{equation}\]

&lt;p&gt;该方程等价于&lt;/p&gt;

\[\begin{equation}
\dfrac{\partial u_1}{\partial x} 
+ \dfrac{\partial u_2}{\partial y} 
+ \dfrac{\partial u_3}{\partial z}=0
\end{equation}\]

&lt;p&gt;运动方程为：&lt;/p&gt;

\[\begin{equation}
\rho\dfrac{\partial \pmb{u}}{\partial t}
+ \rho\pmb{u}\cdot\nabla \pmb{u}
= -\nabla p+ \eta\Delta \pmb{u} +\rho\pmb{F}
\end{equation}\]

&lt;p&gt;当假设\(\pmb{F} = \pmb{0}\)时，该方程等价于&lt;/p&gt;

\[\begin{equation}
\left \{
\begin{aligned}
\rho \left(\dfrac{\partial u_1}{\partial t}
+u_1 \dfrac{\partial u_1}{\partial x}
+u_2 \dfrac{\partial u_1}{\partial y}
+u_3 \dfrac{\partial u_1}{\partial z}\right)
= -\dfrac{\partial p}{\partial x} + \eta
\left( \dfrac{\partial^2 u_1}{\partial x^2} + \dfrac{\partial^2 u_1}{\partial y^2}
+\dfrac{\partial^2 u_1}{\partial z^2}  \right) \\
\rho \left(\dfrac{\partial u_2}{\partial t}
+u_1 \dfrac{\partial u_2}{\partial x}
+u_2 \dfrac{\partial u_2}{\partial y}
+u_3 \dfrac{\partial u_2}{\partial z}\right)
= -\dfrac{\partial p}{\partial y} + \eta
\left( \dfrac{\partial^2 u_2}{\partial x^2} + \dfrac{\partial^2 u_2}{\partial y^2}
+\dfrac{\partial^2 u_2}{\partial z^2}  \right)\\
\rho \left(\dfrac{\partial u_3}{\partial t}
+u_1 \dfrac{\partial u_3}{\partial x}
+u_2 \dfrac{\partial u_3}{\partial y}
+u_3 \dfrac{\partial u_3}{\partial z}\right)
= -\dfrac{\partial p}{\partial z} + \eta
\left( \dfrac{\partial^2 u_3}{\partial x^2} + \dfrac{\partial^2 u_3}{\partial y^2}
+\dfrac{\partial^2 u_3}{\partial z^2}  \right)
\end{aligned}
\right.
\end{equation}\]

&lt;p&gt;&lt;strong&gt;假设条件&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;CMP过程中载荷完全由抛光液来承载，晶片由于抛光液的隔离完全与抛光垫分离，因为膜厚比较博，忽略质量力。&lt;/li&gt;
  &lt;li&gt;假设抛光液是牛顿性流体，在CMP过程中是稳态不可压的，流体的黏性系数是常数\(\eta\)。由于稳态所以\(\dfrac{\partial u_i}{\partial t} = 0\)。&lt;/li&gt;
  &lt;li&gt;满足无量纲润滑条件。即\(\dfrac{\partial^2 u_i}{\partial x^2} + \dfrac{\partial^2 u_i}{\partial y^2}\)比\(\dfrac{\partial^2 u_i}{\partial z^2}\)量级小，可以忽略。&lt;/li&gt;
  &lt;li&gt;在\(z\)轴方向总压力梯度为0，\(z\)轴方向的速度忽略不计。即\(u_3 = 0\)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以连续方程简化为&lt;/p&gt;

\[\begin{equation}
\dfrac{\partial u_1}{\partial x} 
+ \dfrac{\partial u_2}{\partial y} =0
\end{equation}\]

&lt;p&gt;运动方程简化为&lt;/p&gt;

\[\begin{equation}
\left \{
\begin{aligned}
\dfrac{\partial p}{\partial x}
+\rho u_1 \dfrac{\partial u_1}{\partial x}
+\rho u_2 \dfrac{\partial u_1}{\partial y}
&amp;amp;= \eta \dfrac{\partial^2 u_1}{\partial z^2} \\
\dfrac{\partial p}{\partial y}
+\rho u_1 \dfrac{\partial u_2}{\partial x}
+\rho u_2 \dfrac{\partial u_2}{\partial y}
&amp;amp;= \eta \dfrac{\partial^2 u_2}{\partial z^2}
\\
 \dfrac{\partial p}{\partial z} &amp;amp;= 0
\end{aligned}
\right.
\end{equation}\]

&lt;p&gt;上式的坐标系是直角坐标系，将其转化为柱坐标，则速度转换关系如下图&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://cdn.jsdelivr.net/gh/xiang-tao/image-hosting@master/picture/CMPspeed.6ivt4x8iwxc0.png&quot; width=&quot;50%&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;CMP速度关系式&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;变换关系式为:&lt;/p&gt;

\[\begin{equation}
\left \{
\begin{aligned}
x=r\cos\theta \\
y=r\sin\theta \\
z=z
\end{aligned}
\right.
\end{equation}\]

\[\begin{equation}
\left \{
\begin{aligned}
\dfrac{\partial x}{\partial r} = \cos\theta
~~~ \dfrac{\partial x}{\partial \theta}
= -r\cdot \sin\theta \\
\dfrac{\partial y}{\partial r} = \sin\theta
~~~ \dfrac{\partial y}{\partial \theta}
= r\cdot \cos\theta
\end{aligned}
\right.
\end{equation}\]

&lt;!--可参考数学分向量值函数求导相关运算--&gt;

\[\begin{equation}
\left \{
\begin{aligned}
\dfrac{\partial r}{\partial x} = \cos\theta
~~~ \dfrac{\partial \theta}{\partial x}
= -\dfrac{\sin\theta}{r} \\
\dfrac{\partial r}{\partial y} = \sin\theta
~~~ \dfrac{\partial \theta}{\partial y}
= \dfrac{\cos\theta}{r} 
\end{aligned}
\right.
\end{equation}\]

&lt;p&gt;速度关系式&lt;/p&gt;

\[\begin{equation}
\left \{
\begin{aligned}
u_1 &amp;amp;= \omega\cdot\cos\theta-u\cdot\sin\theta \\
u_2 &amp;amp;= \omega\cdot\sin\theta+u\cdot\cos\theta 
\end{aligned}
\right.
\end{equation}\]

&lt;p&gt;于是可得(5)与(6)式的柱坐标形式如下:&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://cdn.jsdelivr.net/gh/xiang-tao/image-hosting@master/picture/4.3ptd88rgsdq0.png&quot; width=&quot;50%&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;(10)&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;p只与x,y相关，即p=p(r,\(\theta\))，记&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://cdn.jsdelivr.net/gh/xiang-tao/image-hosting@master/picture/5.7k69mslimvs0.png&quot; width=&quot;50%&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;(11)&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;对(10)的中间两项在[0,z]上进行两次积分可得&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://cdn.jsdelivr.net/gh/xiang-tao/image-hosting@master/picture/6.411uvg8embc0.png&quot; width=&quot;50%&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;(12)&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;对一阶对z的偏导数进行泰勒展式:&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://cdn.jsdelivr.net/gh/xiang-tao/image-hosting@master/picture/7.3ahyvvwxxvw0.png&quot; width=&quot;50%&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;(13)&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;将(10)中间两项代入(13)，(13)代入(12)，然后再将(12)代入到(10)的第一个公式中，则有&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://cdn.jsdelivr.net/gh/xiang-tao/image-hosting@master/picture/8.3lxudsmnch40.png&quot; width=&quot;50%&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;(14)&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;将(14)沿z轴[0,h]积分，积分过程中采用中矩形公式近似，于是得到了CMP润滑方程&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://cdn.jsdelivr.net/gh/xiang-tao/image-hosting@master/picture/10.978yo8qdzv4.png&quot; width=&quot;50%&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;记晶片中心厚度为\(h_{piv}\)，晶片转角和倾角分别为\(\alpha~~\beta\)，则在(r,\(\theta\))处膜厚h满足&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://cdn.jsdelivr.net/gh/xiang-tao/image-hosting@master/picture/11.6o1ewjpwjh00.png&quot; width=&quot;50%&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;&lt;/div&gt;
&lt;/center&gt;
&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://cdn.jsdelivr.net/gh/xiang-tao/image-hosting@master/CMP-picture/17.4oknbuv2ko00.png&quot; width=&quot;60%&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;转角倾角示意图&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;速度边界条件满足如下:&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://cdn.jsdelivr.net/gh/xiang-tao/image-hosting@master/picture/12.5nc0z2tduzo0.png&quot; width=&quot;50%&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;&lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;其中\(\omega_{\omega}\)为晶片的转速，\(\omega_p\)为抛光垫的转速，d为抛光垫中心到晶片中心的距离。&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://cdn.jsdelivr.net/gh/xiang-tao/image-hosting@master/CMP-picture/16.u4eel6m889s.png&quot; width=&quot;50%&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;速度边界关系图&lt;/div&gt;
&lt;/center&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://cdn.jsdelivr.net/gh/xiang-tao/image-hosting@master/CMP-picture/15.2ht2xt8cqvc0.png&quot; width=&quot;70%&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;无量纲百度解释&lt;/div&gt;
&lt;/center&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://cdn.jsdelivr.net/gh/xiang-tao/image-hosting@master/CMP-picture/14.6d3r6dbagac0.png&quot; width=&quot;70%&quot; /&gt;
    &lt;br /&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;润滑条件百度解释&lt;/div&gt;
&lt;/center&gt;
</description>
        <pubDate>Tue, 14 Sep 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/09/%E5%AF%B9%E6%B5%81%E6%95%88%E5%BA%94%E5%92%8C%E7%A3%81%E5%9C%BA%E7%9A%84CMP%E6%A8%A1%E5%9E%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/09/%E5%AF%B9%E6%B5%81%E6%95%88%E5%BA%94%E5%92%8C%E7%A3%81%E5%9C%BA%E7%9A%84CMP%E6%A8%A1%E5%9E%8B/</guid>
        
        <category>PaperNotes</category>
        
        
      </item>
    
      <item>
        <title>第八章 函数探幽</title>
        <description>&lt;h2 id=&quot;c内联函数&quot;&gt;c++内联函数&lt;/h2&gt;

&lt;h2 id=&quot;引用变量&quot;&gt;引用变量&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;创建引用变量&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;引用的创建&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rats&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rodents&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rats&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//rodents是rats的一个引用&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;说明：此时相当于一个地址上套了两个标签，即rats和rodents的地址相同，其中一个变量改变则另一个随之改变。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;引用和指针的区别&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;指针可以先声明，再初始化，而引用在声明时候必须进行初始化。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;引用的本质&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;引用可以理解成为变量取一个别名，但其本质是一个&lt;strong&gt;const&lt;/strong&gt;指针&lt;/p&gt;

    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rodents&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rats&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rats&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//引用的本质&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;上面的第1行代码的本质是第2行，其中引用rodents扮演的角色与*pr相同&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;赋值与引用&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//声明并初始化，即b是a的一个引用&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//仅仅是赋值，等价于a = temp&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;上面的代码中第2行声明引用并初始化，而第4行仅仅是重新给b赋值，并不能理解成b变成了temp的引用；简而言之就是可以通过初始化声明来设置引用，但不能够通过赋值来设置。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;注意：上述并不是引用的典型用途&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将引用变量作为函数参数&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;按值传递 指针传递 引用传递&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;按值传递&lt;/strong&gt;会产生一个副本，函数的功能将会是对副本的数据进行操作，而实参并不会随之改变。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;指针传递&lt;/strong&gt;和&lt;strong&gt;引用传递&lt;/strong&gt;都不会产生一个新的副本，而是与实际的数据共用。&lt;/p&gt;

    &lt;p&gt;例如交换两个整数的函数声明及调用形式如下:&lt;/p&gt;

    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//按值传递函数声明&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//调用形式&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//指针传递函数声明&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//调用形式&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//引用传递函数声明&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//调用形式&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;需要注意的是指针传递和引用传递他们的功能一样，但是在函数调用以及函数体写法上的区别，初次之外引用传递和按值传递他们除了在函数定义或者声明之处不一样外，其他都是一致的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;引用的属性和特别之处&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;引用加const修饰符来防止数据被修改&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;如果程序员的意图是让函数传递信息，而不需要对传递的信息进行修改，同时又想使用引用，则应使用const&lt;/p&gt;

    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;refcube&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ra&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//此时在函数体中ra不允许修改，否则报错&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;strong&gt;按值传递和引用传递的调用时机&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;如果使用的是基本数据类型，且不希望原始的数据被破坏，数据量小，则应该使用按值传递。&lt;/p&gt;

    &lt;p&gt;如果数据比较大(比如结构和类)，则应该使用引用传递，这样避免了副本的产生从而大大节约了内存和代码的运行时间(因为副本是复制产生的，复制时候需要占用大量的运行时间)。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;临时变量 引用参数和const&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;如果实参与引用参数不匹配，c++将产生临时变量，仅当参数为const引用时候生效，没有const编译器会报错。&lt;/p&gt;

    &lt;p&gt;如果引用参数是const，则产生临时变量的条件是&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;实参的类型正确，但不是左值。&lt;/li&gt;
      &lt;li&gt;实参的类型不正确，但可以转换成正确的类型。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;refcube&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ra&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ra&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ra&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;side&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;side&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;side&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edge&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lens&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;3.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;refcube&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;side&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//ra是side的引用，地址一致&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;refcube&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lens&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//ra是lens[2]的引用，地址一致&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;refcube&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//ra是rd的引用，rd是side引用，因此他们三个地址一致&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;refcube&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//ra是*pd的引用，而*pd=side，因此他们地址一致&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;refcube&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;edge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//ra是一个临时变量，因为edge是int，类型不匹配&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c6&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;refcube&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;7.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//ra是一个临时变量，ra=7.0,尽管7.0是double，但7.0不是左值表达式&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c7&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;refcube&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;side&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;10.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//ra是临时变量,side+10.0尽管是double，但不是左值表达式&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;上面的15 16行也可以说是他们没有名称，从而会产生一个临时变量，产生临时变量的本质是，例如&lt;/p&gt;

    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//ok,c是b的引用,地址一致&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//ok,但会产生临时变量，导致d的地址是临时变量的地址，与a的地址不一样&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
产生临时变量:
int &amp;amp;d =a;
编译器进行了如下操作
int temp = a;将double类型的a的数据存储到int类型的临时变量temp中
int &amp;amp;d =temp;此时d再引用临时变量temp，即d的地址与temp一致
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;也就是所当产生临时变量时候，引用参数的地址不再与传递参数的地址一致，所以改变他们其中一个数的值，另一个不会随之改变。前提是引用使用了const，否则编译会因为类型不同或者不是左值表达式而报错。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 对于未加const的引用当类型不匹配时，有些较老的编译器仍然能够正确运行，只是发出临时变量的警告，这时候的警告我们不能够忽略它，&lt;strong&gt;此外我们应该在函数的引用参数中尽量使用const，&lt;/strong&gt;这样能够接受更多类型的实参，只是当类型不匹配时候const引用参数功能就跟按值传递的功能一样(因为产生了临时变量实参和形参的地址不一样了)，同时在c++11标准中，&lt;strong&gt;&amp;amp;称为左值引用，&amp;amp;&amp;amp;称为右值引用&lt;/strong&gt;，关于&amp;amp;&amp;amp;引用此处不做说明。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将引用用于结构&lt;/p&gt;

    &lt;p&gt;c++设计左值引用的目的主要是针对结构体和类，而不是基本数据类型，原因上面已经说过，这样可以避免副本的产生而大大的减少程序运行时间。结构和类都是用户定义的数据类型，使用方式和使用基本的数据类型一样，例如定义了一个Student的结构，那么引用的时候Student就跟int一样去操作即可。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将引用用于类对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对象 继承和引用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;何时使用引用参数&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sun, 12 Sep 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/09/%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/09/%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD/</guid>
        
        <category>c++</category>
        
        
      </item>
    
      <item>
        <title>gcc 命令参数</title>
        <description>&lt;h2 id=&quot;gcc命令参数&quot;&gt;gcc命令参数&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;gcc -E source_file.c&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　-E，只执行到预编译。直接输出预编译结果。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;gcc -S source_file.c&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　 -S，只执行到源代码到汇编代码的转换，输出汇编代码。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;gcc -c source_file.c&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　-c，只执行到编译，输出目标文件。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;gcc (-E/S/c/) source_file.c -o output_filename&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　-o, 指定输出文件名，可以配合以上三种标签使用。-o 参数可以被省略。这种情况下编译器将使用以下默认名称输出：&lt;/p&gt;

&lt;p&gt;　　-E：预编译结果将被输出到标准输出端口（通常是显示器）&lt;/p&gt;

&lt;p&gt;　　-S：生成名为source_file.s的汇编代码&lt;/p&gt;

&lt;p&gt;　　-c：生成名为source_file.o的目标文件。无标签情况：生成名为a.out的可执行文件。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;gcc -g source_file.c&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　 -g，生成供调试用的可执行文件，可以在gdb中运行。由于文件中包含了调试信息因此运行效率很低，且文件也大不少。这里可以用strip命令重新将文件中debug信息删除。这是会发现生成的文件甚至比正常编译的输出更小了，这是因为strip把原先正常编译中的一些额外信息（如函数名之类）也删除了。用法为 strip a.out&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;gcc -s source_file.c&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　-s, 直接生成与运用strip同样效果的可执行文件（删除了所有符号信息）。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;gcc -O source_file.c&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　-O（大写的字母O），编译器对代码进行自动优化编译，输出效率更高的可执行文件。&lt;/p&gt;

&lt;p&gt;　　-O 后面还可以跟上数字指定优化级别，如：gcc -O2 source_file.c数字越大，越加优化。但是通常情况下，自动的东西都不是太聪明，太大的优化级别可能会使生成的文件产生一系列的bug。一般可选择2；3会有一定风险。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;gcc -Wall source_file.c&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　-W，在编译中开启一些额外的警告（warning）信息。-Wall，将所有的警告信息全开。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;gcc source_file.c -L/path/to/lib -lxxx -I/path/to/include&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　-l,  指定所使用到的函数库，本例中链接器会尝试链接名为libxxx.a的函数库。&lt;/p&gt;

&lt;p&gt;　　-L，指定函数库所在的文件夹，本例中链接器会尝试搜索/path/to/lib文件夹。&lt;/p&gt;

&lt;p&gt;　　-I, 指定头文件所在的文件夹，本例中预编译器会尝试搜索/path/to/include文件夹。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;原文：https://blog.csdn.net/zhubaohua_bupt/article/details/52763639&lt;/p&gt;
</description>
        <pubDate>Fri, 03 Sep 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/09/gcc/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/09/gcc/</guid>
        
        <category>gcc</category>
        
        
      </item>
    
  </channel>
</rss>
